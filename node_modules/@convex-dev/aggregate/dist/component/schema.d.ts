import { type Value as ConvexValue, type Infer } from "convex/values";
export type Item = {
    k: ConvexValue;
    v: ConvexValue;
    s: number;
};
export declare const itemValidator: import("convex/values").VObject<{
    k: any;
    v: any;
    s: number;
}, {
    k: import("convex/values").VAny<any, "required", string>;
    v: import("convex/values").VAny<any, "required", string>;
    s: import("convex/values").VFloat64<number, "required">;
}, "required", "k" | "v" | "s" | `k.${string}` | `v.${string}`>;
export declare const aggregate: import("convex/values").VObject<{
    count: number;
    sum: number;
}, {
    count: import("convex/values").VFloat64<number, "required">;
    sum: import("convex/values").VFloat64<number, "required">;
}, "required", "count" | "sum">;
export type Aggregate = Infer<typeof aggregate>;
declare const _default: import("convex/server").SchemaDefinition<{
    btree: import("convex/server").TableDefinition<import("convex/values").VObject<{
        namespace?: any;
        root: import("convex/values").GenericId<"btreeNode">;
        maxNodeSize: number;
    }, {
        root: import("convex/values").VId<import("convex/values").GenericId<"btreeNode">, "required">;
        namespace: import("convex/values").VAny<any, "optional", string>;
        maxNodeSize: import("convex/values").VFloat64<number, "required">;
    }, "required", "root" | "namespace" | "maxNodeSize" | `namespace.${string}`>, {
        by_namespace: ["namespace", "_creationTime"];
    }, {}, {}>;
    btreeNode: import("convex/server").TableDefinition<import("convex/values").VObject<{
        aggregate?: {
            count: number;
            sum: number;
        } | undefined;
        items: {
            k: any;
            v: any;
            s: number;
        }[];
        subtrees: import("convex/values").GenericId<"btreeNode">[];
    }, {
        items: import("convex/values").VArray<{
            k: any;
            v: any;
            s: number;
        }[], import("convex/values").VObject<{
            k: any;
            v: any;
            s: number;
        }, {
            k: import("convex/values").VAny<any, "required", string>;
            v: import("convex/values").VAny<any, "required", string>;
            s: import("convex/values").VFloat64<number, "required">;
        }, "required", "k" | "v" | "s" | `k.${string}` | `v.${string}`>, "required">;
        subtrees: import("convex/values").VArray<import("convex/values").GenericId<"btreeNode">[], import("convex/values").VId<import("convex/values").GenericId<"btreeNode">, "required">, "required">;
        aggregate: import("convex/values").VObject<{
            count: number;
            sum: number;
        } | undefined, {
            count: import("convex/values").VFloat64<number, "required">;
            sum: import("convex/values").VFloat64<number, "required">;
        }, "optional", "count" | "sum">;
    }, "required", "items" | "subtrees" | "aggregate" | "aggregate.count" | "aggregate.sum">, {}, {}, {}>;
}, true>;
export default _default;
//# sourceMappingURL=schema.d.ts.map